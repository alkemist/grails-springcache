h1. Springcache Plugin

The Springcache plugin allows you to easily add the following functionality to your Grails project:
 # Caching of Spring bean methods (typically Grails service methods).
 # Caching of page fragments generated by Grails controllers.
 # Cache flushing when Spring bean methods or controller actions are invoked.

The plugin depends on the [EHCache|http://ehcache.org/] and EHCache-Web libraries.

h2. Upgrading from earlier plugin versions

Successive versions of the plugin have introduced some non-backwards compatible changes. If you are upgrading from an earlier version you will need to consider the following:

h3. Upgrading from 1.1.* to 1.2:
 * The plugin no longer uses caching and flushing models. Instead cache names are referenced directly by the annotations. This means you will need to 'inline' your model definitions from @Config.groovy@ to your annotations.
 * The plugin no longer supports alternate cache libraries, it's EHCache or nothing.

h3. From pre 1.1:
 * You will need to change the import statements for your @Cacheable@ and @CacheFlush@ annotations to point to the @grails.plugin.springcache.annotations@ package.
 * The default map cache is no more. Grails includes EHCache and it's very easy to configure so that is now the default.
 * If you were using a cache provider other than EHCache you will need to write some code to implement your own @grails.plugin.springcache.CacheProvider@ - see below.
 * Caching and flushing model configuration has changed slightly and is now simpler. It should be no more than a couple of minutes work to adapt your existing config. See the examples below.

h2. Applying caching and flushing behaviour to methods

The typical use case for method caching is when you have Grails service methods that invoke expensive operations such as HTTP gets, web service calls, filesystem IO, etc. Although you _can_ use the Springcache plugin to cache service methods that query or update GORM domain objects you should consider whether it's more appropriate to use the Hibernate 2nd level cache (see the relevant sections in the Grails documentation).

Simply add @grails.plugin.springcache.annotations.Cacheable("cacheName") to methods that should cache their results and @grails.plugin.springcache.annotations.CacheFlush(["cacheName1", "cacheName2"]) to methods that should flush the cache.

Be aware that the annotations will only have any effect on Spring-managed beans. If you create instances of your class directly rather than getting them from the application context they will not be decorated with caching/flushing behaviour.

The @Cacheable@ annotation takes a single cache name while the @CacheFlush@ annotation can take an array so that multiple caches can be flushed at once. You can omit the square braces on the @CacheFlush@ annotation if you only need to flush a single cache.

A simple example might be:

h4. PiracyService.groovy
{code}
@Cacheable("pirateCache")
def getPirates() {
	// return a list of pirates
}

@Cacheable("pirateCache")
def findPirates(name) {
	// return a particular pirate
}

@Cacheable("shipCache")
def getShips() {
	// return a list of ships
}

@CacheFlush("pirateCache")
void registerNewPirate(Pirate sailor) {
	// store a new pirate
}

@CacheFlush("shipCache")
void registerNewShip(Ship ship) {
	// store a new ship
}

@CacheFlush(["pirateCache", "shipCache"])
void registerNewShipWithCrew(Ship ship, Collection<Sailor> crew) {
	// store a new ship and associated pirates
}
{code}

This ties the flushes on the register* methods to the particular caches they affect, so after calling @registerNewPirate@ the methods @getPirates@ and @findPirates@ will re-populate their cached results but @getShips@ would still use any cached results from previous calls. Calling @registerNewShipWithCrew@ will flush both caches as it is changing data associated with both.

Note that it is fine for multiple methods to share the same caches. Both @getPirates@ and @findPirates@ in the example above share the same caching model. Cache entries are keyed on target object (the service instance in this case), method name and call parameters so there should be no confusion when using the same caches on multiple methods.

There are various strategies you can adopt in naming and grouping caches, this example shouldn't be seen as definitive.

h2. Page fragment caching

The same annotations can be applied to controller actions and the plugin will then cache the page fragment output by the plugin whether this is done by rendering a GSP, using a @MarkupBuilder@ closure, rendering text directly or whatever.

Composing pages so that they can be optimally cached requires some thought. The plugin uses a servlet filter that runs 'inside' the SiteMesh filter provided by Grails. This means that cached output is decorated by SiteMesh and the resulting can therefore contain uncached content from the SiteMesh template. In addition you can use caching at a modular level to cache the output of controller actions invoked using the @g:include@ tag. Combining these techniques leads to powerful modular page caching. For example, you can cache the output of the 'main' controller then use @g:include@ tags in the SiteMesh layout to include content on the page that is cached separately - and can be flushed separately - from the main body of the page.

h3. Example: caching Grails CRUD pages

Grails' standard scaffolded CRUD pages provide a good example of how caching and flushing can be applied. For example, let's take an *Album* domain class. The scaffolded controller could be annotated like this:

h4. AlbumController.groovy
{code}
class AlbumController {
	// the index action is uncached as it just performs a redirect to list
    def index = {
        redirect(action: "list", params: params)
    }

	@Cacheable("albumControllerCache")
    def list = {
		// standard Grails scaffolding code omitted
    }

	@Cacheable("albumControllerCache")
    def create = {
		// standard Grails scaffolding code omitted
    }

	@CacheFlush(["albumControllerCache", "artistControllerCache", "latestControllerCache", "popularControllerCache"])
    def save = {
		// standard Grails scaffolding code omitted
    }

	@Cacheable("albumControllerCache")
    def show = {
		// standard Grails scaffolding code omitted
    }

	@Cacheable("albumControllerCache")
    def edit = {
		// standard Grails scaffolding code omitted
    }

	@CacheFlush(["albumControllerCache", "latestControllerCache", "popularControllerCache"])
    def update = {
		// standard Grails scaffolding code omitted
    }

	@CacheFlush(["albumControllerCache", "artistControllerCache", "latestControllerCache", "popularControllerCache"])
    def delete = {
		// standard Grails scaffolding code omitted
    }
}
{code}

The 'list', 'show', 'create' and 'edit' pages are all cached. Note that 'show' and 'edit' rely on an domain object id parameter and this will be included in the cache key so that @/album/show/1@ and @/album/show/2@ are cached separately. The 'save', 'update' and 'delete' actions are flushing caches. Note that in addition to flushing the cache used by the 'list', 'show', 'create' and 'edit' actions they are flushing other caches which are content caches for controllers whose output should be refreshed if @Album@ data changes.

h3. Example: decorating a cached page with dynamic content using SiteMesh

h3. Example: a modular page using multiple cached sections

h3. Page fragment caching and content negotiation

h3. Customising key generation for page fragment caching

h3. Full page caching

The plugin only provides page fragment caching rather than full page caching. Full page caching is very simple to apply using the EHCache-Web library that the Springcache plugin uses. See my blog post [here|http://adhockery.blogspot.com/2010/02/full-page-caching-in-grails-with.html] for details.

h2. Configuring caches

Caches referenced by the annotations can be configured, either in an @ehcache.xml@ (usually kept in the @grails-app/conf@ directory) file, using @EhCacheFactoryBean@ definitions in @grails-app/conf/spring/resources.groovy@ or via @Config.groovy@. If you do not configure caches individually they will be created on demand using defaults.

h3. Configuring caches with resources.groovy

You can configure caches in @grails-app/conf/spring/resources.groovy@ using Spring's [EhCacheFactoryBean|http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/cache/ehcache/EhCacheFactoryBean.html]. For example:

h4. grails-app/conf/spring/resources.groovy
{code}
pirateCache(EhCacheFactoryBean) {bean ->
	cacheManager = ref("springcacheCacheManager")
	cacheName = "pirateCache"
	eternal = true
	diskPersistent = true
	memoryStoreEvictionPolicy = "LFU"
}
{code}

h3. Configuring caches with Config.groovy

With the Springcache plugin you can define caches in @Config.groovy@ in a similar way. For example:

h4. grails-app/conf/Config.groovy
{code}
springcache {
	caches {
		pirateCache {
			eternal = true
			diskPersistent = true
			memoryStoreEvictionPolicy = "LFU"
		}
	}
}
{code}
Under the hood this is simply setting up @EhCacheFactoryBean@ instances in the Spring context, so it is up to you whether you prefer to use @resources.groovy@ or @Config.groovy@ there is very little difference.

h2. Tips

h3. Tearing down caches in tests

In integration test and some types of functional test (e.g. Selenium RC tests when not running in remote mode) your tests can have Spring beans automatically injected. You can use this facility to tear down caches between tests. For example:
{code}
def springcacheCacheManager // auto-injected net.sf.ehcache.CacheManager

void tearDown() {
    super.tearDown()
	springcacheCacheManager.cacheNames.each {
		def cache = springcacheCacheManager.getEhcache(it)
		cache.flush()
		cache.clearStatistics()
	}
}
{code}

h3. Disabling

Rather than tearing down caches between tests you may prefer to disable the plugin altogether. This is done by setting the config key @springcache.disabled = true@ which can be done on a per-environment basis. For example:
{code}
springcache {
	// cache definitions, etc
}

environments {
	test {
		springcache.disabled = true
	}
}
{code}

h3. Logging Output

To see logging from the plugin set the logging level on "grails.plugin.springcache" in your Config.groovy.

h2. FAQ

h3. My cache config doesn't seem to be working.
Ensure all your config for the Springcache plugin is nested inside a single 'springcache' block in Config.groovy otherwise only the last block will take effect.

h2. Release Notes
h4. 1.2
 * Adds page fragment caching via annotations on controllers.
 * Simplifies config by getting rid of caching and flushing models and having annotations refer to cache names directly.
h4. 1.1.3
 * Fixes bug where an expired ehcache element whose key is still in the cache can cause the plugin to think the key still maps to a valid value.
 * Allows configuration of ehcache caches directly in Config.groovy
h4. 1.1.2
 * Automatically create ehcache caches if they are not explicitly configured in @ehcache.xml@
h4. 1.1.1
 * Fixes bug where plugin crashes if disabled
h4. 1.1
 * Complete rewrite to support Grails 1.2 and Spring 3.0.
 * Requires Grails 1.2+
h4. 1.0.1
 * Fixes bug where plugin causes crash if disabled when debug logging is switched on.
 * Fixes compatibility with Java 1.5.
h4. 1.0
 * Configure alternate caching providers via Config.groovy rather than having to override bean definitions in resources.groovy
 * Removed dependency on joda-time which was only there for testing
 * Better synchronization for getting caches from the mapcache CacheManager
h4. 0.2
 * Configure caching and flushing models via Config.groovy
 * Flag to disable plugin entirely for testing environments
h4. 0.1
 * Initial release

h2. Contact

The plugin code is hosted on [GitHub|http://github.com/robfletcher/grails-springcache]. Please feel free to fork the plugin and contribute patches.

Please raise defects or enhancements on [JIRA|http://jira.codehaus.org/browse/GRAILSPLUGINS/component/14010].

Questions, comments? [rob@energizedwork.com|mailto:rob@energizedwork.com].